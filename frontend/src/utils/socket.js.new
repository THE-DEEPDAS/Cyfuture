// MOCK IMPLEMENTATION - to avoid "Class extends undefined" error
import store from "../store";
import {
  SOCKET_MESSAGE_RECEIVED,
  SOCKET_USER_TYPING,
  SOCKET_USER_STOP_TYPING,
  SOCKET_USER_ONLINE,
  SOCKET_USER_OFFLINE,
} from "../constants/messageConstants";

console.log("Using mock socket implementation in frontend");

// Mock socket implementation
const dummySocket = {
  id: 'mock-socket-id',
  connected: false,
  auth: {},
  connect: () => {
    console.log("[MOCK] Socket connect called");
    dummySocket.connected = true;
    // Simulate connect event handlers
    dummySocket._connectHandlers.forEach(handler => handler());
    return dummySocket;
  },
  disconnect: () => {
    console.log("[MOCK] Socket disconnect called");
    dummySocket.connected = false;
    return dummySocket;
  },
  _eventHandlers: {},
  _connectHandlers: [],
  on: (event, callback) => {
    console.log(`[MOCK] Socket registered handler for event: ${event}`);
    if (event === 'connect') {
      dummySocket._connectHandlers.push(callback);
    } else {
      if (!dummySocket._eventHandlers[event]) {
        dummySocket._eventHandlers[event] = [];
      }
      dummySocket._eventHandlers[event].push(callback);
    }
    return dummySocket;
  },
  off: (event) => {
    console.log(`[MOCK] Socket removed handlers for event: ${event}`);
    if (event === 'connect') {
      dummySocket._connectHandlers = [];
    } else {
      dummySocket._eventHandlers[event] = [];
    }
    return dummySocket;
  },
  emit: (event, data, callback) => {
    console.log(`[MOCK] Socket emit: ${event}`, data);
    if (typeof callback === 'function') {
      setTimeout(() => callback({ success: true }), 100);
    }
    return dummySocket;
  },
  to: () => ({ emit: () => {} }),
  join: () => {},
  leave: () => {},
  removeAllListeners: () => {
    console.log("[MOCK] Socket removed all listeners");
    dummySocket._eventHandlers = {};
    dummySocket._connectHandlers = [];
  }
};

// Export mock socket instance
export const socket = dummySocket;

// Connected rooms tracking
const connectedRooms = new Set();

// Mock connect function
export const connectSocket = (token) => {
  console.log("[MOCK] Connecting socket with token");
  dummySocket.auth = { token };
  
  // Simulate successful connection
  setTimeout(() => {
    if (!dummySocket.connected) {
      dummySocket.connect();
    }
  }, 100);
};

// Mock room management
export const joinConversation = (conversationId) => {
  console.log(`[MOCK] Joining conversation: ${conversationId}`);
  connectedRooms.add(conversationId);
};

export const leaveConversation = (conversationId) => {
  console.log(`[MOCK] Leaving conversation: ${conversationId}`);
  connectedRooms.delete(conversationId);
};

// Mock message sending
export const sendMessage = async (message) => {
  console.log("[MOCK] Sending message:", message);
  return { success: true, message };
};

// Mock typing indicators
export const emitTyping = (conversationId, isTyping) => {
  console.log(`[MOCK] Emitting typing status: ${isTyping} for conversation: ${conversationId}`);
};

// Mock read status
export const markMessagesAsRead = async (conversationId) => {
  console.log(`[MOCK] Marking messages as read for conversation: ${conversationId}`);
  return { success: true };
};

// Mock cleanup
export const cleanupSocket = () => {
  console.log("[MOCK] Cleaning up socket");
  dummySocket.removeAllListeners();
  connectedRooms.clear();
};

// Mock socket getter
export const getSocket = () => {
  if (!dummySocket.connected) {
    dummySocket.connect();
  }
  return dummySocket;
};

// Export default socket object
export default {
  socket: dummySocket,
  connectSocket,
  joinConversation,
  leaveConversation,
  sendMessage,
  emitTyping,
  markMessagesAsRead,
  cleanupSocket,
  getSocket,
};
