// filepath: d:\Cyfuture 3\backend\controllers\applicationController.js
import Application from "../models/Application.js";
import Job from "../models/Job.js";
import Resume from "../models/Resume.js";
import {
  analyzeCandidate,
  generateChatResponse,
  detectLanguage,
} from "../utils/llm.js";
import { calculateMatchScore } from "../services/enhancedJobMatching.js";
import { notifyUser } from "../utils/notification.js";
import asyncHandler from "express-async-handler";

// @desc    Submit job application
// @route   POST /api/applications/:jobId
// @access  Private/Candidate
export const applyToJob = asyncHandler(async (req, res) => {
  const { jobId } = req.params;
  const { resumeId, coverLetter, screeningResponses = [] } = req.body;

  // Validate required fields
  if (!resumeId) {
    res.status(400);
    throw new Error("Please select a resume");
  }

  // Find job and check if it exists and is active
  const job = await Job.findById(jobId).populate("company");
  
  if (!job) {
    res.status(404);
    throw new Error("Job not found");
  }

  // Check screening questions
  if (job.screeningQuestions?.length > 0) {
    // Verify we have responses
    if (!screeningResponses || screeningResponses.length === 0) {
      res.status(400);
      throw new Error("Please answer all screening questions");
    }
    
    // Transform screeningResponses if they're in simple string format
    let formattedResponses = screeningResponses;
    
    // Check if we need to format responses (if they're just strings)
    if (typeof screeningResponses[0] === 'string' || !screeningResponses[0].question) {
      formattedResponses = job.screeningQuestions.map((question, index) => ({
        question: question._id,
        questionText: question.question, // Store question text for context
        response: screeningResponses[index] || ""
      }));
    } else {
      // Add question text to properly formatted responses
      formattedResponses = screeningResponses.map(response => {
        const questionObj = job.screeningQuestions.find(
          q => q._id.toString() === response.question.toString()
        );
        return {
          ...response,
          questionText: questionObj?.question || "Unknown question"
        };
      });
    }
    
    // Validate required questions are answered
    for (let i = 0; i < job.screeningQuestions.length; i++) {
      const question = job.screeningQuestions[i];
      const response = formattedResponses.find(
        resp => resp.question && resp.question.toString() === question._id.toString()
      );
      
      if (question.required && (!response || !response.response || !response.response.trim())) {
        res.status(400);
        throw new Error(`Please answer the required question: ${question.question}`);
      }
    }
    
    // Replace with formatted responses
    req.body.screeningResponses = formattedResponses;
  }

  if (!job.isActive) {
    res.status(400);
    throw new Error("This job is no longer accepting applications");
  }

  // Check if already applied
  const existingApplication = await Application.findOne({
    job: jobId,
    candidate: req.user._id,
  });

  if (existingApplication) {
    res.status(400);
    throw new Error("You have already applied for this job");
  }

  try {
    // Find the resume
    const resume = await Resume.findOne({
      _id: resumeId,
      user: req.user._id,
    });

    if (!resume) {
      res.status(404);
      throw new Error("Resume not found");
    }

    // Get match score and analysis
    let matchScore = 0;
    let llmAnalysis = null;

    try {
      // Calculate match score safely with error handling
      matchScore = await calculateMatchScore(job, resume.parsedData);
    } catch (matchError) {
      console.error("Error calculating match score:", matchError);
      // Default to a moderate score if calculation fails
      matchScore = 50;
    }

    // Get LLM analysis if enabled
    if (job.llmEvaluation?.enabled) {
      try {
        llmAnalysis = await analyzeCandidate(
          resume.parsedData,
          job,
          req.body.screeningResponses
        );
      } catch (analysisError) {
        console.error("Error generating LLM analysis:", analysisError);
        // Continue without LLM analysis
      }
    }

    // Create application
    const application = await Application.create({
      job: jobId,
      candidate: req.user._id,
      resume: resumeId,
      coverLetter,
      screeningResponses: req.body.screeningResponses,
      status: "pending",
      matchScore,
      llmAnalysis,
      messages: [], // Initialize with empty messages array
    });

    // Send application notification
    try {
      const sendApplicationNotification = async (application, job, analysis) => {
        // Notify company about new application
        await notifyUser(
          job.company._id,          "application",
          "New Job Application",
          `${req.user.name} has applied for ${job.title}`,
          {
            jobId: job._id,
            applicationId: application._id,
            candidateId: req.user._id,
            score: analysis?.score || null,
          }
        );

        // Notify candidate about application status
        if (analysis?.isRecommended === false) {
          await notifyUser(
            req.user._id,
            "APPLICATION_FEEDBACK",
            "Application Status Update",
            `Thank you for applying to ${
              job.title
            }. Based on our initial assessment, we regret to inform you that your profile may not be the best match for this role at this time. ${
              analysis?.analysis?.feedback || ""
            }`,
            {
              jobId: job._id,
              applicationId: application._id,
              status: "reviewing",
              feedback: analysis?.analysis?.improvements || [],
            }
          );
        } else {
          await notifyUser(
            req.user._id,            "application",
            "Application Received",
            `Your application for ${job.title} has been received and is under review.`,
            {
              jobId: job._id,
              applicationId: application._id,
              status: "reviewing",
            }
          );
        }
      };

      await sendApplicationNotification(application, job, llmAnalysis);
    } catch (notificationError) {
      console.error("Error sending notifications:", notificationError);
      // Continue even if notifications fail
    }

    res.status(201).json(application);
  } catch (error) {
    console.error("Application submission error:", error);
    res.status(500);
    throw new Error(`Failed to submit application: ${error.message}`);
  }
});
