/**
 * Text-based Resume Parser
 *
 * This module implements a simplified resume parsing algorithm that extracts:
 * 1. Skills
 * 2. Experience
 * 3. Projects
 * 4. Education
 *
 * It works with plain text content instead of relying on PDF parsing libraries.
 */

/**
 * Main function to parse resume text
 * @param {Buffer} fileBuffer - The file buffer (can be PDF or text)
 * @param {String} fileName - The original file name
 * @returns {Object} - Parsed resume data
 */
export const parseResumeText = async (fileBuffer, fileName = "") => {
  try {
    console.log("Starting text-based resume parsing");

    // Convert buffer to text - this is a simple conversion that works for text files
    // For PDF files, we'll get some garbage text but can still extract some information
    const text = fileBuffer.toString('utf-8');
    console.log("Converted file to text, length:", text.length);

/**
 * Extract sections from text based on OpenResume algorithm
 * @param {string} text - Raw text from resume
 * @returns {Object} - Object with sections as keys and their content as values
 */
const extractSections = (text) => {
  // Split text into lines and remove empty lines
  const lines = text
    .split("\n")
    .map((line) => line.trim())
    .filter(Boolean);

  // Common section headers (case insensitive)
  const commonSections = [
    "SKILLS",
    "EXPERIENCE",
    "EDUCATION",
    "PROJECTS",
    "ACHIEVEMENTS",
    "WORK EXPERIENCE",
    "EMPLOYMENT",
    "PROFESSIONAL EXPERIENCE",
    "TECHNICAL SKILLS",
    "RESPONSIBILITIES",
    "CERTIFICATIONS",
    "AWARDS",
    "PUBLICATIONS",
    "LANGUAGES",
    "INTERESTS",
  ];

  // Find potential section headers
  let sections = {};
  let currentSection = null;
  let currentContent = [];

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const upperLine = line.toUpperCase();

    // Check if line is a potential section header
    const isHeader =
      // All caps, single word or short phrase
      (upperLine === line && line.length >= 4 && line.split(" ").length <= 3) ||
      // Matches common section names
      commonSections.some((section) => upperLine.includes(section)) ||
      // Line ends with colon
      line.endsWith(":") ||
      // Bullet point at start of line
      line.startsWith("•") ||
      // Line is in all caps and short
      (upperLine === line && line.length <= 30);

    if (isHeader) {
      // Save previous section if it exists
      if (currentSection) {
        sections[currentSection] = currentContent.join("\n");
      }

      // Clean up section header
      currentSection = line.replace(":", "").trim();
      currentContent = [];
    } else if (currentSection) {
      currentContent.push(line);
    }
  }

  // Save the last section
  if (currentSection && currentContent.length > 0) {
    sections[currentSection] = currentContent.join("\n");
  }

  // If no sections were found using headers, try basic content classification
  if (Object.keys(sections).length === 0) {
    sections = classifyContent(text);
  }

  return sections;
};

const classifyContent = (text) => {
  const sections = {};
  const lines = text
    .split("\n")
    .map((line) => line.trim())
    .filter(Boolean);

  let skillsSection = [];
  let experienceSection = [];
  let projectsSection = [];

  lines.forEach((line) => {
    // Classify line based on content
    if (
      line.match(/^[•\-]\s*(proficient|skilled|expertise|experience)\s+in/i) ||
      line.match(/^(languages|technologies|tools|frameworks|platforms):/i) ||
      /javascript|python|java|react|node|html|css|sql|mongodb|aws|docker|git/i.test(
        line
      )
    ) {
      skillsSection.push(line);
    } else if (
      line.match(/\b(20\d{2}|19\d{2})\s*(-|–|to)\s*(20\d{2}|present)\b/i) ||
      line.match(/\b(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\b/i) ||
      /engineer|developer|manager|director|analyst|specialist|consultant/i.test(
        line
      )
    ) {
      experienceSection.push(line);
    } else if (
      line.match(/\b(developed|created|built|implemented|designed)\b/i) ||
      line.match(/^[•\-]\s*(project|application|system|platform):/i) ||
      /github|gitlab|bitbucket|website|app|application/i.test(line)
    ) {
      projectsSection.push(line);
    }
  });

  if (skillsSection.length > 0) sections["SKILLS"] = skillsSection.join("\n");
  if (experienceSection.length > 0)
    sections["EXPERIENCE"] = experienceSection.join("\n");
  if (projectsSection.length > 0)
    sections["PROJECTS"] = projectsSection.join("\n");

  return sections;
};

/**
 * Extract skills from sections
 * @param {Object} sections - Sections extracted from text
 * @returns {Array} - Array of skills
 */
const extractSkills = (content) => {
  if (!content || typeof content !== "string") {
    console.log("Invalid content provided to extractSkills:", content);
    return [];
  }

  const skills = new Set();

  // Common skill categories and their keywords
  const skillCategories = {
    programming: [
      "python",
      "javascript",
      "java",
      "c++",
      "typescript",
      "react",
      "node",
      "angular",
      "html",
      "css",
    ],
    databases: ["sql", "mongodb", "postgresql", "mysql", "redis", "firebase"],
    tools: [
      "git",
      "docker",
      "kubernetes",
      "aws",
      "azure",
      "gcp",
      "jenkins",
      "jira",
    ],
    frameworks: [
      "express",
      "django",
      "flask",
      "spring",
      "laravel",
      "vue",
      "next.js",
    ],
    ai_ml: [
      "machine learning",
      "deep learning",
      "tensorflow",
      "pytorch",
      "nlp",
      "computer vision",
      "ai",
    ],
  };

  // Split by common delimiters
  const parts = content
    .split(/[,•\n\r]/)
    .map((part) => part.trim())
    .filter(Boolean);

  parts.forEach((part) => {
    // Check each part against skill categories
    for (const category in skillCategories) {
      skillCategories[category].forEach((skill) => {
        if (part.toLowerCase().includes(skill.toLowerCase())) {
          skills.add(skill);
        }
      });
    }
  });

  return Array.from(skills);
};

/**
 * Extract experience from sections
 * @param {Object} sections - Sections extracted from text
 * @returns {Array} - Array of experience descriptions
 */
const extractExperience = (content) => {
  if (!content || typeof content !== "string") {
    return [];
  }

  const experiences = [];
  const lines = content
    .split(/\n|\r/)
    .map((line) => line.trim())
    .filter(Boolean);

  let currentExp = null;
  let currentDetails = [];

  for (const line of lines) {
    // Check for new experience entry
    if (
      line.match(
        /^[•★]\s|\d{4}[-–]\d{4}|\d{4}[-–]present|jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec/i
      )
    ) {
      if (currentExp) {
        currentExp.description = currentDetails.join("\n");
        experiences.push(currentExp);
      }

      currentExp = { title: "", company: "", duration: "", description: "" };

      // Extract date ranges
      const dateMatch = line.match(
        /(\w+\s?\d{4})\s*[-–]\s*(\w+\s?\d{4}|present)/i
      );
      if (dateMatch) {
        currentExp.duration = dateMatch[0];
        currentExp.title = line.replace(dateMatch[0], "").trim();
      } else {
        currentExp.title = line;
      }

      currentDetails = [];
    } else if (currentExp) {
      currentDetails.push(line);
    }
  }

  // Add the last experience
  if (currentExp && currentDetails.length > 0) {
    currentExp.description = currentDetails.join("\n");
    experiences.push(currentExp);
  }

  return experiences;
};

/**
 * Extract projects from sections
 * @param {Object} sections - Sections extracted from text
 * @returns {Array} - Array of project descriptions
 */
const extractProjects = (content) => {
  if (!content || typeof content !== "string") {
    return [];
  }

  const projects = [];
  const lines = content
    .split(/\n|\r/)
    .map((line) => line.trim())
    .filter(Boolean);

  let currentProject = null;
  let currentDetails = [];

  for (const line of lines) {
    // Check for new project entry (starts with bullet or is a short header)
    if (
      line.match(/^[•\-*]\s|^[\w\s]{2,30}:/) ||
      (line.length < 50 && !currentProject)
    ) {
      if (currentProject) {
        currentProject.description = currentDetails.join("\n");

        // Extract technologies from description
        const techWords = currentProject.description.match(
          /using|with|built on|developed with|implemented in/i
        );
        if (techWords) {
          const techStartIndex =
            currentProject.description.indexOf(techWords[0]) +
            techWords[0].length;
          const techPart = currentProject.description.substring(
            techStartIndex,
            techStartIndex + 50
          );
          const technologies = techPart
            .split(/[,&]/)
            .map((t) => t.trim())
            .filter((t) => t.length > 1);
          currentProject.technologies = technologies;
        }

        projects.push(currentProject);
      }

      currentProject = {
        name: line.replace(/^[•\-*]\s|:$/, "").trim(),
        description: "",
        technologies: [],
      };

      currentDetails = [];
    } else if (currentProject) {
      currentDetails.push(line);
    }
  }

  // Add the last project
  if (currentProject && currentDetails.length > 0) {
    currentProject.description = currentDetails.join("\n");

    // Extract technologies from description
    const techWords = currentProject.description.match(
      /using|with|built on|developed with|implemented in/i
    );
    if (techWords) {
      const techStartIndex =
        currentProject.description.indexOf(techWords[0]) + techWords[0].length;
      const techPart = currentProject.description.substring(
        techStartIndex,
        techStartIndex + 50
      );
      const technologies = techPart
        .split(/[,&]/)
        .map((t) => t.trim())
        .filter((t) => t.length > 1);
      currentProject.technologies = technologies;
    }

    projects.push(currentProject);
  }

  return projects;
};

// Main parsing function
const parseResume = async (pdfBuffer, fileName = "") => {
  try {
    console.log("Starting enhanced resume parsing");

    // Extract text from PDF
    const text = await extractPDFText(pdfBuffer);
    console.log("Successfully extracted text from PDF, length:", text.length);

    // Extract metadata from filename if available
    const metadata = {
      fileName: fileName || "Unnamed Resume",
      uploadDate: new Date(),
      fileType: fileName ? fileName.split(".").pop().toLowerCase() : "unknown",
    };    // Extract metadata from filename if available
    const metadata = {
      fileName: fileName || "Unnamed Resume",
      uploadDate: new Date(),
      fileType: fileName ? fileName.split(".").pop().toLowerCase() : "unknown",
    };

    // Extract sections
    const sections = extractSections(text);
    console.log("Found sections:", Object.keys(sections));

    // Parse data
    const parsedData = {
      skills: [],
      experience: [],
      projects: [],
    };

    // Extract skills
    const skillsSection = Object.keys(sections).find(
      (key) =>
        key.toUpperCase().includes("SKILL") ||
        key.toUpperCase().includes("TECHNICAL")
    );
    if (skillsSection) {
      parsedData.skills = extractSkills(sections[skillsSection]);
    } else {
      // Try to extract skills from the entire text if no specific section found
      parsedData.skills = extractSkills(text);
    }

    // Extract experience
    const experienceSection = Object.keys(sections).find(
      (key) =>
        key.toUpperCase().includes("EXPERIENCE") ||
        key.toUpperCase().includes("EMPLOYMENT")
    );
    if (experienceSection) {
      parsedData.experience = extractExperience(sections[experienceSection]);
    }

    // Extract projects
    const projectsSection = Object.keys(sections).find((key) =>
      key.toUpperCase().includes("PROJECT")
    );
    if (projectsSection) {
      parsedData.projects = extractProjects(sections[projectsSection]);
    }

    console.log("Extraction results:");
    console.log("Skills:", parsedData.skills.length);
    console.log("Experience entries:", parsedData.experience.length);
    console.log("Projects:", parsedData.projects.length);

    return {
      ...metadata,
      parsedData,
    };
  } catch (error) {
    console.error("Resume parsing error:", error);
    // Return minimal data structure instead of throwing
    return {
      fileName: fileName || "Unnamed Resume",
      uploadDate: new Date(),
      fileType: fileName ? fileName.split(".").pop().toLowerCase() : "unknown",
      parsedData: {
        skills: [],
        experience: [],
        projects: [],
      }
    };
  }
};

export { parseResume };
